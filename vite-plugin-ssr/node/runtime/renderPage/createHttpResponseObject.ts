export { createHttpResponseObject }
export { createHttpResponseObjectRedirect }
export type { HttpResponse }

import { inferEarlyHintLink } from '../html/injectAssets/inferHtmlTags'
import type { PageAsset, GetPageAssets } from './getPageAssets'
import { assert } from '../utils'
import type { HtmlRender } from '../html/renderHtml'
import type { PageConfig } from '../../../shared/page-configs/PageConfig'
import { isErrorPage } from '../../../shared/error-page'
import type { RenderHook } from './executeOnRenderHtmlHook'
import type { StatusCodeAbort, StatusCodeError, UrlRedirect } from '../../../shared/route/abort'
import { getHttpResponseBody, getHttpResponseBodyStreamHandlers, HttpResponseBody } from './getHttpResponseBody'

type StatusCode = 200 | 404 | 500 | StatusCodeAbort
type ContentType = 'application/json' | 'text/html;charset=utf-8'
type EarlyHint = PageAsset & {
  earlyHintLink: string
}
type ResponseHeaders = [string, string][]
type HttpResponse = {
  statusCode: StatusCode
  headers: ResponseHeaders
  // We don't use @deprecated to avoid TypeScript to remove the JSDoc
  /** **Deprecated**: use `headers` instead, see TODO */
  contentType: ContentType
  /** **Deprecated**: use `headers` instead, see TODO */
  earlyHints: EarlyHint[]
} & HttpResponseBody
async function createHttpResponseObject(
  htmlRender: null | HtmlRender,
  renderHook: null | RenderHook,
  pageContext: {
    isClientSideNavigation: boolean
    _pageId: null | string
    is404: null | boolean
    errorWhileRendering: null | Error
    __getPageAssets: GetPageAssets
    _pageConfigs: PageConfig[]
    _abortStatusCode?: StatusCodeError
  }
): Promise<HttpResponse | null> {
  if (htmlRender === null) {
    return null
  }
  assert(renderHook || typeof htmlRender === 'string')

  let statusCode: StatusCode | undefined = pageContext._abortStatusCode
  if (!statusCode) {
    const isError = !pageContext._pageId || isErrorPage(pageContext._pageId, pageContext._pageConfigs)
    if (pageContext.errorWhileRendering) {
      assert(isError)
    }
    if (!isError) {
      assert(pageContext.is404 === null)
      statusCode = 200
    } else {
      assert(pageContext.is404 === true || pageContext.is404 === false)
      statusCode = pageContext.is404 ? 404 : 500
    }
  }

  // The `.pageContext.json` HTTP request's body is generated by `@brillout/json-serializer` thus always a string
  assert(!pageContext.isClientSideNavigation || typeof htmlRender === 'string')

  const earlyHints: EarlyHint[] = []
  {
    const assets = await pageContext.__getPageAssets()
    assets.forEach((asset) => {
      // Don't early hint fallback fonts, https://github.com/brillout/vite-plugin-ssr/issues/624
      if (isFontFallback(asset, earlyHints)) return
      earlyHints.push({
        ...asset,
        earlyHintLink: inferEarlyHintLink(asset)
      })
    })
  }

  const contentType = pageContext.isClientSideNavigation ? 'application/json' : 'text/html;charset=utf-8'
  return getHttpResponse(statusCode, contentType, [], htmlRender, earlyHints, renderHook)
}

function createHttpResponseObjectRedirect(pageContext: { _urlRedirect: UrlRedirect }): HttpResponse {
  const { url, statusCode } = pageContext._urlRedirect
  assert(url)
  assert(statusCode)
  assert(300 <= statusCode && statusCode <= 399)
  const headers: ResponseHeaders = [['Location', url]]
  return getHttpResponse(
    statusCode,
    'text/html;charset=utf-8',
    headers,
    `<p style="display: none">Redirecting to ${url}</p>`
  )
}

function getHttpResponse(
  statusCode: StatusCode,
  contentType: ContentType,
  headers: ResponseHeaders,
  htmlRender: HtmlRender,
  earlyHints: EarlyHint[] = [],
  renderHook: null | RenderHook = null
): HttpResponse {
  headers.push(['Content-Type', contentType])

  return {
    statusCode,
    headers,
    contentType, // TODO/v1-release: remove
    earlyHints, // TODO/v1-release: remove
    get body() {
      return getHttpResponseBody(htmlRender, renderHook)
    },
    ...getHttpResponseBodyStreamHandlers(htmlRender, renderHook)
  }
}

function isFontFallback(asset: PageAsset, earlyHints: EarlyHint[]): boolean {
  if (asset.assetType !== 'font') {
    return false
  }
  const fontUrlBase = removeFileExtentionAndHash(asset.src)
  return earlyHints.some((hint) => {
    return hint.assetType === 'font' && removeFileExtentionAndHash(hint.src) === fontUrlBase
  })
}

function removeFileExtentionAndHash(assetUrl: string): string {
  assert(!assetUrl.includes('\\'))

  // The logic below doesn't work for '/assets/chunk-0e184ced.js'
  assert(!assetUrl.endsWith('.js'))

  const paths = assetUrl.split('/')
  {
    const filename = paths[paths.length - 1]!
    const filenameParts = filename.split('.')
    assert(filenameParts.length >= 2)
    // User may set config.build.rollupOptions.output.assetFileNames => we can't assume the filename to be `*.${hash}.${ext}`
    const filenameBase = filenameParts.slice(0, filenameParts.length === 2 ? -1 : -2)
    assert(filenameBase.length >= 1)
    paths[paths.length - 1] = filenameBase.join('.')
  }
  return paths.join('/')
}
