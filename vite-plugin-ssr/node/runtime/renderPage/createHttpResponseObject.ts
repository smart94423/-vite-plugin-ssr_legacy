export { createHttpResponseObject }
export type { HttpResponse }

import {
  getStreamReadableNode,
  getStreamReadableWeb,
  pipeToStreamWritableWeb,
  pipeToStreamWritableNode,
  StreamPipeNode,
  StreamPipeWeb,
  StreamReadableNode,
  StreamReadableWeb,
  StreamWritableNode,
  StreamWritableWeb,
  isStream,
  getStreamName,
  inferStreamName,
  isStreamWritableWeb,
  isStreamWritableNode,
  isStreamReadableWeb,
  isStreamReadableNode,
  isStreamPipeWeb,
  isStreamPipeNode
} from '../html/stream'
import { inferEarlyHintLink } from '../html/injectAssets/inferHtmlTags'
import type { PageAsset, GetPageAssets } from './getPageAssets'
import { assert, assertUsage, assertWarning } from '../utils'
import { getHtmlString, type HtmlRender } from '../html/renderHtml'
import type { PageConfig } from '../../../shared/page-configs/PageConfig'
import { isErrorPage } from '../../../shared/error-page'
import type { RenderHook } from './executeOnRenderHtmlHook'

type StatusCode = 200 | 404 | 500
type ContentType = 'application/json' | 'text/html;charset=utf-8'
type EarlyHint = PageAsset & {
  earlyHintLink: string
}
type HttpResponse = {
  statusCode: StatusCode
  contentType: ContentType
  body: string
  getBody: () => Promise<string>
  getReadableWebStream: () => StreamReadableWeb
  pipe: (writable: StreamWritableWeb | StreamWritableNode) => void
  earlyHints: EarlyHint[]
  /** @deprecated */
  getNodeStream: () => Promise<StreamReadableNode>
  /** @deprecated */
  getWebStream: () => StreamReadableWeb
  /** @deprecated */
  pipeToNodeWritable: StreamPipeNode
  /** @deprecated */
  pipeToWebWritable: StreamPipeWeb
}
async function createHttpResponseObject(
  htmlRender: null | HtmlRender,
  renderHook: null | RenderHook,
  pageContext: {
    isClientSideNavigation: boolean
    _pageId: null | string
    is404: null | boolean
    errorWhileRendering: null | Error
    __getPageAssets: GetPageAssets
    _pageConfigs: PageConfig[]
  }
): Promise<HttpResponse | null> {
  if (htmlRender === null) {
    return null
  }
  assert(renderHook || typeof htmlRender === 'string')

  let statusCode: StatusCode
  {
    const isError = !pageContext._pageId || isErrorPage(pageContext._pageId, pageContext._pageConfigs)
    if (pageContext.errorWhileRendering) {
      assert(isError)
    }
    if (!isError) {
      assert(pageContext.is404 === null)
      statusCode = 200
    } else {
      assert(pageContext.is404 === true || pageContext.is404 === false)
      statusCode = pageContext.is404 ? 404 : 500
    }
  }

  // The `.pageContext.json` HTTP request's body is generated by `@brillout/json-serializer` thus always a string
  assert(!pageContext.isClientSideNavigation || typeof htmlRender === 'string')

  const streamDocs = 'See https://vite-plugin-ssr.com/stream for more information.'

  const earlyHints: EarlyHint[] = []
  {
    const assets = await pageContext.__getPageAssets()
    assets.forEach((asset) => {
      // Don't early hint fallback fonts, https://github.com/brillout/vite-plugin-ssr/issues/624
      if (isFontFallback(asset, earlyHints)) return
      earlyHints.push({
        ...asset,
        earlyHintLink: inferEarlyHintLink(asset)
      })
    })
  }

  return {
    statusCode,
    contentType: pageContext.isClientSideNavigation ? 'application/json' : 'text/html;charset=utf-8',
    earlyHints,
    get body() {
      if (typeof htmlRender !== 'string') {
        assertUsage(
          false,
          getErrMsg('body', 'Use `pageContext.httpResponse.pipe()` or `pageContext.httpResponse.getBody()` instead')
        )
      }
      const body = htmlRender
      return body
    },
    async getBody(): Promise<string> {
      const body = await getHtmlString(htmlRender)
      return body
    },
    async getNodeStream() {
      assertWarning(
        false,
        '`pageContext.httpResponse.getNodeStream()` is outdated, use `pageContext.httpResponse.pipe()` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const nodeStream = await getStreamReadableNode(htmlRender)
      if (nodeStream === null) {
        assertUsage(false, getErrMsg('getNodeStream()', getFixMsg('readable', 'node')))
      }
      return nodeStream
    },
    getWebStream() {
      assertWarning(
        false,
        '`pageContext.httpResponse.getWebStream(res)` is outdated, use `pageContext.httpResponse.getReadableWebStream(res)` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const webStream = getStreamReadableWeb(htmlRender)
      if (webStream === null) {
        assertUsage(false, getErrMsg('getWebStream()', getFixMsg('readable', 'web')))
      }
      return webStream
    },
    getReadableWebStream() {
      const webStream = getStreamReadableWeb(htmlRender)
      if (webStream === null) {
        assertUsage(false, getErrMsg('getReadableWebStream()', getFixMsg('readable', 'web')))
      }
      return webStream
    },
    pipeToWebWritable(writable: StreamWritableWeb) {
      assertWarning(
        false,
        '`pageContext.httpResponse.pipeToWebWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const success = pipeToStreamWritableWeb(htmlRender, writable)
      if (!success) {
        assertUsage(false, getErrMsg('pipeToWebWritable()'))
      }
    },
    pipeToNodeWritable(writable: StreamWritableNode) {
      assertWarning(
        false,
        '`pageContext.httpResponse.pipeToNodeWritable(res)` is outdated, use `pageContext.httpResponse.pipe(res)` instead. ' +
          streamDocs,
        { onlyOnce: true, showStackTrace: true }
      )
      const success = pipeToStreamWritableNode(htmlRender, writable)
      if (!success) {
        assertUsage(false, getErrMsg('pipeToNodeWritable()'))
      }
    },
    pipe(writable: StreamWritableNode | StreamWritableWeb) {
      const getErrMsgMixingStreamTypes = (writableType: 'Web Writable' | 'Node.js Writable') =>
        `The ${getErrMsgBody()} while a ${
          writableType as string
        } was passed to pageContext.httpResponse.pipe() which is contradictory. You cannot mix a Web Stream with a Node.js Stream.` as const
      if (isStreamWritableWeb(writable)) {
        const success = pipeToStreamWritableWeb(htmlRender, writable)
        if (success) {
          return
        } else {
          assert(isStreamReadableWeb(htmlRender) || isStreamPipeWeb(htmlRender))
          assertUsage(false, getErrMsgMixingStreamTypes('Web Writable'))
        }
      }
      if (isStreamWritableNode(writable)) {
        const success = pipeToStreamWritableNode(htmlRender, writable)
        if (success) {
          return
        } else {
          assert(isStreamReadableNode(htmlRender) || isStreamPipeNode(htmlRender))
          assertUsage(false, getErrMsgMixingStreamTypes('Node.js Writable'))
        }
      }
      assertUsage(
        false,
        `The argument \`writable\` passed to \`pageContext.httpResponse.pipe(writable)\` doesn't seem to be ${getStreamName(
          'writable',
          'web'
        )} nor ${getStreamName('writable', 'node')}.`
      )
    }
  }

  function getErrMsg(method: string, msgAddendum?: string) {
    assert(!msgAddendum || !msgAddendum.endsWith('.'))
    const errMsgBody = getErrMsgBody()
    return [`pageContext.httpResponse.${method} can't be used because the ${errMsgBody}`, msgAddendum, streamDocs]
      .filter(Boolean)
      .join('. ')
  }
  function getErrMsgBody() {
    assert(renderHook)
    const { hookFilePath, hookName } = renderHook
    const hookReturnType = getHookReturnType()
    assert(['a ', 'an ', 'the '].some((s) => hookReturnType.startsWith(s)))
    const errMsgBody = `${hookName as string}()\ hook defined by ${hookFilePath} provides ${
      hookReturnType as string
    }` as const
    assert(!errMsgBody.endsWith(' '))
    return errMsgBody
  }
  function getHookReturnType() {
    if (typeof htmlRender === 'string') {
      return 'an HTML string'
    } else if (isStream(htmlRender)) {
      return inferStreamName(htmlRender)
    } else {
      assert(false)
    }
  }
  function getFixMsg(type: 'pipe' | 'readable', standard: 'web' | 'node') {
    const streamName = getStreamName(type, standard)
    assert(['a ', 'an ', 'the '].some((s) => streamName.startsWith(s)))
    assert(renderHook)
    const { hookFilePath, hookName } = renderHook
    return `Make sure the ${hookName}() defined by ${hookFilePath} hook provides ${streamName} instead`
  }
}

function isFontFallback(asset: PageAsset, earlyHints: EarlyHint[]): boolean {
  if (asset.assetType !== 'font') {
    return false
  }
  const fontUrlBase = removeFileExtentionAndHash(asset.src)
  return earlyHints.some((hint) => {
    return hint.assetType === 'font' && removeFileExtentionAndHash(hint.src) === fontUrlBase
  })
}

function removeFileExtentionAndHash(assetUrl: string): string {
  assert(!assetUrl.includes('\\'))

  // The logic below doesn't work for '/assets/chunk-0e184ced.js'
  assert(!assetUrl.endsWith('.js'))

  const paths = assetUrl.split('/')
  {
    const filename = paths[paths.length - 1]!
    const filenameParts = filename.split('.')
    assert(filenameParts.length >= 2)
    // User may set config.build.rollupOptions.output.assetFileNames => we can't assume the filename to be `*.${hash}.${ext}`
    const filenameBase = filenameParts.slice(0, filenameParts.length === 2 ? -1 : -2)
    assert(filenameBase.length >= 1)
    paths[paths.length - 1] = filenameBase.join('.')
  }
  return paths.join('/')
}
