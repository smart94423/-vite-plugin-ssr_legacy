import { Link } from '@brillout/docpress'

We can use `import()` to load a component in a lazy manner:

```diff
- import SomeComponent from 'some-component'
+ const { SomeComponent } = await import('some-component')
```

> Vite automatically code-splits at `import()`: the code of `some-component` isn't included in the initial JavaScript bundle and
> is loaded only if/when `import('some-component')` is executed.

Common use cases:
 - **Performance**: we can use `import()` to defer loading a heavy component (e.g. an interactive map), so that the user can already interact with our page before even the browser starts loading that heavy component.
 - **Client-side only components**: we can use `import()` to avoid loading/rendering a component on the server-side. (Some component libraries cannot be server-side rendered, see <Link href="/client-only-components" />.)

UI framework support for lazy-loading components using `import()`:
 - [React Docs > Code-Splitting > `React.lazy`](https://reactjs.org/docs/code-splitting.html#reactlazy)
 - [Vue 3 Docs > Async Components](https://v3.vuejs.org/guide/component-dynamic-async.html#async-components)
 - [Vue 2 Docs > Async Components](https://vuejs.org/v2/guide/components-dynamic-async.html)


## React Example

```jsx
// /pages/location/select.page.jsx

import React from 'react'

export function Page() {
  // Users can see and interact with the button "Please select a location"
  // before the browser starts loading the code for <Map>.
  return <>
    <button>Please select a location</button>
    <Map />
  </>
}

// <Map> is:
//  - Lazy-loaded
//  - Loaded & rendered only in the browser
function Map() {
  const [Component, setComponent] = React.useState(() => Loading)

  // useEffect() callbacks are only run in the browser, consequently the map component
  // is loaded and rendererd only in the browser.
  React.useEffect(() => {
    // @ts-expect-error The type provided by @types/react is wrong
    setComponent(() => React.lazy(() => import('some-heavy-map-component')))
  }, [])

  return (
    <React.Suspense fallback={<Loading />}>
      <Component />
    </React.Suspense>
  )
}

function Loading() {
  return <div>Loading map...</div>
}
```

We can extract the logic into a generic `<ClientOnly>` component:

```jsx
// ClientOnly.jsx

export { ClientOnly }

import React from 'react'

function ClientOnly(props) {
  const [Component, setComponent] = React.useState(() => props.fallback)

  React.useEffect(() => {
    setComponent(() => React.lazy(props.component))
  }, [])

  return (
    <React.Suspense fallback={props.fallback}>
      <Component />
    </React.Suspense>
  )
}
```
```jsx
import { ClientOnly } from './ClientOnly'

function Map() {
  return (
    <ClientOnly
      component={() => import('some-heavy-map-component')}
      fallback={<Loading />}
    />
  )
}
function Loading() {
  return <div>Loading map...</div>
}
```

See also:
 - [github.com/arthurgailes/vite-plugin-ssr_dynamic-import-example](https://github.com/arthurgailes/vite-plugin-ssr_dynamic-import-example)
   - See [/pages/index/index.page.jsx](https://github.com/arthurgailes/vite-plugin-ssr_dynamic-import-example/blob/ecf7cda9beac5cae7b0eb642bd77d25f71e0f2e5/pages/index/index.page.jsx#L20-L35)


## Vue Example

See [#278 - comment](https://github.com/brillout/vite-plugin-ssr/issues/278#issuecomment-1072952681). Contribution welcome to create a full example.
