import { RepoLink, Link } from 'libframe-docs/components'

## Overview

Environment: `Browser`.

By default `vite-plugin-ssr` does [Server Routing](/SR-vs-CR#server-routing).
We can do [Client Routing](/SR-vs-CR#client-routing) instead by using `useClientRouter()` instead of [`getPage()`](/getPage).

> In general, we recommend Server Routing, see [Server Routing VS Client Routing](/SR-vs-CR).

```js
// *.page.client.js
// Environment: Browser

import { useClientRouter } from 'vite-plugin-ssr/client/router'

useClientRouter({
  async render(pageContext) {
    if (pageContext.isHydration) {
      // We hydrate the first page
      // ...
    } else {
      // We render a new page (when the user navigates)
      // ...
    }
  }
})
```

> If you don't know what hydration is, see <Link href="/hydration" />.

## Examples

React example:
 - <RepoLink path='/examples/react-full/renderer/_default.page.client.tsx' />
 - <RepoLink path='/examples/react-full/pages/index.page.tsx' /> (example of using <code>navigate()</code>)

Vue example:
 - <RepoLink path='/examples/vue-full/renderer/_default.page.client.ts' />
 - <RepoLink path='/examples/vue-full/renderer/app.ts' />
 - <RepoLink path='/examples/vue-full/pages/index.page.vue' /> (example of using <code>navigate()</code>)

## Usage & Options

```js
// _default.page.client.js
// Environment: Browser

import { useClientRouter } from 'vite-plugin-ssr/client/router'
import { render, hydrate } from 'some-view-framework'

const { hydrationPromise } = useClientRouter({
  async render(pageContext) {
    // `pageContext.isHydration` is set by `vite-plugin-ssr` and is `true` when the page
    // is already rendered to HTML.
    if (pageContext.isHydration) {
      // We hydrate the first page. (Since we do SSR, the first page is already
      // rendered to HTML and we merely have to hydrate it.)
      await hydrate(pageContext.Page)
    } else {
      // We render a new page. (When the user navigates to a new page.)
      await render(pageContext.Page)
    }
  },

  // If `ensureHydration: true` then `vite-plugin-ssr` ensures that the first render is always
  // a hydration. (In other words, the hydration process is never interrupted â€” even if the
  // user clicks on a link before the hydration started. Default value: `false`.)
  // If we use Vue, we need `ensureHydration: true` to avoid "Hydration Mismatch" errors.
  // If we use React, we can leave `ensureHydration: false` for a slight performance improvement.
  ensureHydration: true,

  // See `Link prefetching` section below. Default value: `false`.
  prefetchLinks: true,

  // To create custom page transition animations
  onTransitionStart,
  onTransitionEnd
})

hydrationPromise.then(() => {
  console.log('Hydration finished; page is now interactive.')
})

function onTransitionStart() {
  console.log('Page transition start')
  // For example:
  document.body.classList.add('page-transition')
}
function onTransitionEnd() {
  console.log('Page transition end')
  // For example:
  document.body.classList.remove('page-transition')
}
```

> Note that `pageContext` is completely discarded and created anew upon page navigation.
> (That's why the context object is called `pageContext` &mdash; not `appContext`.)

We can keep using `<a href="/some-url">` links: the Client Router automatically intercepts clicks on `<a>` elements.

We can skip the Client Router by adding the `rel="external"` attribute, e.g. `<a rel="external" href="/some/url">The Client Router won't intercept me</a>`.

We can use
[`navigate('/some/url')`](/navigate)
to programmatically navigate our user to a new page.

By default, the Client-side Router scrolls to the top of the page upon page change;
we can use `<a keep-scroll-position />` / `navigate('/some/url', { keepScrollPosition: true })`
if we want to preserve the scroll position instead. (Useful for [Nested Routes](/nested-routes).)

## Link prefetching

By default,
when the user hovers his mouse over a link `<a href="/some-url">`, the static assets of the page `/some-url` are loaded.
This means that static assets are often already loaded before even the user clicks on the link.

We can prefetch even more eagerly by setting `useClientRouter({ prefetchLinks: true })`: the links are then prefetched as soon as they appear in the user's browser viewport.

We can override the link prefetching behavior for individual links by setting `<a data-prefetch="false" href="/some-url" />`.

> Only the page's static assets are prefetched; the page's `pageContext` is currently not prefetched but it's a work-in-progress feature, see [#246](https://github.com/brillout/vite-plugin-ssr/issues/246).
